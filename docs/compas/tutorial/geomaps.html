<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Geometric Maps &#8212; COMPAS 1.16.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Plotters" href="plotters.html" />
    <link rel="prev" title="Remote Procedure Calls" href="rpc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="geometric-maps">
<h1>Geometric Maps</h1>
<p>Geometric maps provide a simple, but effective way to identify points that can be
considered equal up to a specified precision. A geometric map basically divides
3D space into cubes sized according to the specified resolution. Cubes can only
be sized in discrete steps, each step corresponding to an order of magnitude.
All points within the cube collapse to the corner closest to the origin of the
coordinate system.</p>
<p>A geometric map uses a dictionary to map string representations of XYZ coordinates
to an index in a list, a key in another dictionary, or to an actual geometric location.
The keys of a dictionary form a set. Therefore the keys are unique and lookups in
a dictionary are very fast.</p>
<section id="comparing-distances">
<h2>Comparing distances</h2>
<p>The concept is best explained with an example. Consider a set of line segments defined
by their start and end point coordinates. To determine how the lines are connected,
we could compute the distance between each point and all other points, identifying
a match as soon as the distance is below a tolerance value.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">compas</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">compas</span><span class="o">.</span><span class="n">json_load</span><span class="p">(</span><span class="n">compas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lines.json&#39;</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

<span class="n">tol</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">tol2</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
    <span class="n">u</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">v</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no match has been found for the start point yet</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">sp</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no match has been found for the end point yet</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ep</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if both points have been found in the current list of vertices iteration can stop</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># the start point is not in the list of vertices that were already identified</span>
        <span class="n">u</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># the end point is not in the list of vertices</span>
        <span class="c1"># that were already identified</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>

    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="c1"># verify the result</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We are not really comparing distances between points, but rather the distance
per coordinate axis. This has the advantage that when the points don’t match
the calculation gets interrupted faster than when calculating the full spatial
distance.</p>
</div>
</section>
<section id="geometric-mapping">
<h2>Geometric mapping</h2>
<p>The code above works fine and is fast enough for small sets of lines.
However, computation time grows exponentially when the number of lines increases.
Therefore, things slow down pretty quickly…</p>
<p>A better way is to use a geometric map.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">compas</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">compas</span><span class="o">.</span><span class="n">json_load</span><span class="p">(</span><span class="n">compas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lines.json&#39;</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

<span class="n">tol</span> <span class="o">=</span> <span class="s1">&#39;3f&#39;</span>
<span class="n">vertexdict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;{0[0]:.</span><span class="si">{1}</span><span class="s2">},{0[1]:.</span><span class="si">{1}</span><span class="s2">},{0[2]:.</span><span class="si">{1}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;{0[0]:.</span><span class="si">{1}</span><span class="s2">},{0[1]:.</span><span class="si">{1}</span><span class="s2">},{0[2]:.</span><span class="si">{1}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">vertexdict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span>
    <span class="n">vertexdict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

<span class="n">key_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertexdict</span><span class="p">)}</span>

<span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertexdict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">edges</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key_index</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">key_index</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>

<span class="c1"># verify the result</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="identifying-elements">
<h2>Identifying elements</h2>
<p>Geometric maps are used internally for many things, such as computing the connectivity between geometric objects as illustrated above.
This is for example the mechanism behind <code class="xref py py-meth docutils literal notranslate"><span class="pre">Network.from_lines()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Mesh.from_polygons()</span></code>.</p>
<p>Another task geometric maps are useful for is identification of elemenets of data structures based on selected (CAD) geometry.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">compas</span>
<span class="kn">import</span> <span class="nn">compas_rhino</span>

<span class="kn">from</span> <span class="nn">compas.datastructures</span> <span class="kn">import</span> <span class="n">Mesh</span>

<span class="n">guid</span> <span class="o">=</span> <span class="n">compas_rhino</span><span class="o">.</span><span class="n">select_mesh</span><span class="p">()</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">RhinoMesh</span><span class="o">.</span><span class="n">from_guid</span><span class="p">(</span><span class="n">guid</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">to_compas</span><span class="p">()</span>

<span class="n">guids</span> <span class="o">=</span> <span class="n">compas_rhino</span><span class="o">.</span><span class="n">select_points</span><span class="p">()</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">compas_rhino</span><span class="o">.</span><span class="n">get_point_coordinates</span><span class="p">(</span><span class="n">guids</span><span class="p">)</span>

<span class="n">gkey_vertex</span> <span class="o">=</span> <span class="p">{</span><span class="n">geometric_key</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_coordinates</span><span class="p">(</span><span class="n">vertex</span><span class="p">)):</span> <span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">()}</span>

<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
    <span class="n">gkey</span> <span class="o">=</span> <span class="n">geometric_key</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gkey</span> <span class="ow">in</span> <span class="n">gkey_vertex</span><span class="p">:</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="n">gkey_vertex</span><span class="p">[</span><span class="n">gkey</span><span class="p">]</span>

        <span class="c1"># do something to this vertex</span>
        <span class="c1"># for example mark it as fixed</span>
        <span class="c1"># or add a load to it based on the name of the matching point</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">COMPAS</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorial.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="geometry.html">Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="meshes.html">Meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="volmeshes.html">Vol(umetric) Meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="robots.html">Robots</a></li>
<li class="toctree-l2"><a class="reference internal" href="numericaldata.html">Numerical Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="rpc.html">Remote Procedure Calls</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Geometric Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotters.html">Plotters</a></li>
<li class="toctree-l2"><a class="reference internal" href="colors.html">Colors and Color Maps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins.html">Extension points</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devguide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../tutorial.html">Tutorial</a><ul>
      <li>Previous: <a href="rpc.html" title="previous chapter">Remote Procedure Calls</a></li>
      <li>Next: <a href="plotters.html" title="next chapter">Plotters</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Block Research Group - ETH Zurich.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>